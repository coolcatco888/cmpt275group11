#summary A walkthrough for the keyboard.

==Intro==

A walkthrough for using textfields and the keyboard, and how to get the screen to scroll up with the keyboard. Also get labels to show what was just typed.


===How To===

*1. Creating the textfield*<br>
First, open the viewcontroller.xib file in interface builder. Drag a textfield from the library into the view. Then open the viewcontroller.h file, and declare your textfield: type in {{{IBOutlet UITextField *textField;}}} (where "textField" is the name and can be anything you want,) after {{{UIViewController{}}}. Then, declare your accessors by typing {{{@property (nonatomic, retain) UITextField *textField;}}} after {{{ } }}}and before {{{@end}}}. Next, implement your accessors by going to the viewcontroller.m file and typing in {{{@synthesize textField;}}}. Finally, find the {{{-(void)dealloc}}} method and add {{{[textField release];}}} to it, above {{{[super dealloc];}}}.
<br> If you want to add the label, do the same thing, just change textfield to label, and {{{UITextField}}} to {{{UILabel}}}.
<br><br><br>
*2. Connecting it up in Interface Builder*<br>
Go back to viewcontroller.xib in interface builder. Right-click File's Owner, and look for the little circle next to textField, under Outlets. Click and drag that circle to the textfield you want in the view. It should now appear next to the circle, and if you hover over it, the selected textfield in the view should highlight. Do the same for the label if you have it.
<br><br><br>
*3. Recognizing when the keyboard will appear*<br>
First, we need to register to be notified by the {{{NSNotificationCenter}}} model class when the keyboard will show up. We do that by adding the following method to viewcontroller.m:
{{{
- (void)viewWillAppear:(BOOL)animated {
   [[NSNotificationCenter defaultCenter] 
      addObserver:self
      selector:@selector(keyboardWillShow:)
      name:UIKeyboardWillShowNotification
      object:self.view.window];

   [super viewWillAppear:animated];
}
}}}
We also need to unregister when the view is released. We do this by adding the following method (right underneath the previous one, to keep things organized):
{{{
- (void)viewWillDisappear:(BOOL)animated {
   [[NSNotificationCenter defaultCenter]
      removeObserver:self
      name:UIKeyboardWillShowNotification
      object:nil];

   [super viewWillDisappear:animated];
}
}}}
What we are doing when we write these methods is actually overriding the methods from the superclass. What we write is basically the same, we just added some code that will register us with NSNotificationCenter.
<br><br><br>
*4. Deciding when to scroll, and by how much*<br>
Type in the following method after {{{viewWillDisappear}}}:
{{{
- (void)keyboardWillShow:(NSNotification *)notif {

   NSDictionary* info = [notif userInfo];
   NSValue* aValue = [info objectForKey:UIKeyboardBoundsUserInfoKey];
   CGSize keyboardSize = [aValue CGRectValue].size;
   float bottomPoint = (textField.frame.origin.y + textField.frame.size.height + 10);
   scrollAmount = keyboardSize.height - (self.view.frame.size.height - bottomPoint);

   if (scrollAmount > 0) {
      moveViewUp = YES;
      [self scrollTheView: YES];
   }else
      moveViewUp = NO;
}
}}}
This method finds the height of the keyboard and the textframe, and decides how much to scroll based on these, as well as the location of the textfield. It checks to see if the view should be moved up, and acts accordingly.
<br><br><br>
*5. Scrolling the view*<br>
You may have noticed a method in the last method called {{{scrollTheView}}}. Well, this isn't included, and we must implement it ourselves. To do that we use the animation features built in to the view.
{{{
- (void)scrollTheView:(BOOL)movedUp {

   [UIView beginAnimations:nil context:NULL];
   [UIView setAnimationDuration:0.3];
   CGRect rect = self.view.frame;
   if(movedUp) {
      rect.origin.y -= scrollAmount;
   }else {
      rect.origin.y += scrollAmount;
   }
   self.view.frame = rect;
   [UIView commitAnimations];
}
}}}
<br><br><br>
*6. Updating viewcontroller.h*<br>
We have now written a method or two, but we haven't declared them, so go back to viewcontroller.h. Where your instance variables go, add {{{BOOL moveViewUp;}}} and {{{CGFloat scrollAmount;}}}. Right before {{{@end}}}, add {{{- (void)scrollTheView:(BOOL)movedUp;}}}.
<br><br><br>
*7. Lowering the view again*<br>
Pretty self-explanatory. The textfield relinquishes its status as the First Responder, and scrolls back down if necessary.
{{{
-(BOOL)textFieldShouldReturn:(UITextField *) theTextField {
   [theTextField resignFirstResponder];
   if (moveViewUp)
      [self scrollTheView:NO];
   return YES;
}
}}}
<br><br>
*8. Adding the TextFieldDelegate protocol*<br>
{{{textFieldShouldReturn}}} is a method declared by the {{{UITextFieldDelegate}}} protocol. On a basic level, adopting a protocol declares methods for you. To do this, go to viewcontroller.h and type {{{<UITextFieldDelegate>}}} after {{{UIViewController}}} and before {{{}}}}.
<br><br><br>
*9. More Connecting in Interface Builder*<br>
Open up viewcontroller.xib, and right click file's owner. Right click the textfield, but on the right side in between the x and the circle. Under outlets, drag the circle next to delegate to File's Owner.  Scrolling is now done!
<br><br><br>
*10. Create a way to store the text*<br>
Before we can do anything with the typed text, we must store it in an instance variable. In the header file, type in {{{NSString *savedText;}}} and it's accessors: {{{@property (nonatomic, retain) NSString *savedText;}}}. Then add {{{@synthesize savedText;}}} to the implementation file. 
<br><br><br>
*11. Doing stuff with the text...*<br>
Add the following method to viewcontroller.m:
{{{
- (void)updateSavedText {
   self.savedText = textField.text;
   label.text = self.savedText;
}
}}}
Also add {{{[self updateSavedText];}}} to textFieldShouldReturn, right before {{{return YES;}}}. Then, add {{{- (void)updateSavedText;}}} to the header file, and finally, add {{{[savedText release];}}} to the dealloc method.
<br><br><br>
*12. Sit back and admire your work!*